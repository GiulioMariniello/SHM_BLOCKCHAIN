// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

interface IOracle {
    function getSensorData(uint sensorId) external view returns (
        uint samplingFrequency, 
        uint maxValue, 
        uint minValue, 
        uint anomalyCount, 
        uint startTime, 
        uint endTime, 
        uint autoDiagValue, 
        bytes32 dataHash
    );
}

/**
 * @title StructuralMonitoring
 * @dev This contract manages the monitoring of structural health data.
 * It checks the quality and originality of sensor data before recording the data hash on the blockchain.
 * The oracle serves as the validator and submits data for verification.
 */
contract StructuralMonitoring is AccessControl {
    // Role definitions for access control
    bytes32 public constant ADMIN_ROLE = keccak256("ADMIN_ROLE");

    // Structure for sensor reference parameters
    struct SensorParameters {
        uint max;            // Maximum acceptable value
        uint min;            // Minimum acceptable value
        uint maxError;       // Maximum allowable error percentage
        uint sampleCount;    // Expected number of samples in 10 minutes
        uint maxAutoDiag;    // Maximum self-diagnostic parameter value
        uint minAutoDiag;    // Minimum self-diagnostic parameter value
    }

    // Mapping of sensor ID to its reference parameters
    mapping(uint => SensorParameters) public sensorParameters;

    // Last recorded timestamp for continuity check
    uint public lastTimestamp;

    // Oracle contract for fetching sensor data
    IOracle public oracle;

    // Event to notify the successful storage of a data hash
    event DataHashStored(bytes32 indexed dataHash, uint indexed timestamp);
    event DataValidated(bytes32 indexed dataHash, uint indexed timestamp, bool success);
    event DataSavedToIPFS(string indexed ipfsHash, uint indexed timestamp);

    /**
     * @dev Constructor to set up roles and the initial oracle address.
     * @param oracleAddress The address of the oracle contract to fetch sensor data.
     */
    constructor(address oracleAddress) {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender); // Default admin role for the deployer
        _grantRole(ADMIN_ROLE, msg.sender);         // Assign deployer as an admin
        oracle = IOracle(oracleAddress);
    }

    /**
     * @dev Initializes the reference parameters for a specific sensor.
     * @param sensorId The ID of the sensor.
     * @param max The maximum acceptable value.
     * @param min The minimum acceptable value.
     * @param maxError The maximum allowable error percentage.
     * @param sampleCount The expected number of samples in 10 minutes.
     * @param maxAutoDiag The maximum self-diagnostic parameter value.
     * @param minAutoDiag The minimum self-diagnostic parameter value.
     */
    function initializeSensorParameters(
        uint sensorId,
        uint max,
        uint min,
        uint maxError,
        uint sampleCount,
        uint maxAutoDiag,
        uint minAutoDiag
    ) public {
        require(hasRole(ADMIN_ROLE, msg.sender), "Only admin can initialize parameters");
        sensorParameters[sensorId] = SensorParameters(max, min, maxError, sampleCount, maxAutoDiag, minAutoDiag);
    }

    /**
     * @dev Validates data from the oracle and stores the result.
     * @param sensorId The ID of the sensor to validate.
     * @param ipfsHash The IPFS hash of the valid data.
     */
    function validateFromOracle(uint sensorId, string memory ipfsHash) public {
        (
            uint samplingFrequency, 
            uint maxValue, 
            uint minValue, 
            uint anomalyCount, 
            uint startTime, 
            uint endTime, 
            uint autoDiagValue, 
            bytes32 dataHash
        ) = oracle.getSensorData(sensorId);

        // Check timestamp continuity
        require(startTime == lastTimestamp + 1, "Timestamp is not consecutive.");
        
        // Retrieve the sensor's parameters
        SensorParameters memory params = sensorParameters[sensorId];
        
        // Validate parameters against received data
        bool success = true;
        if (
            maxValue > params.max || 
            minValue < params.min || 
            anomalyCount > params.maxError || 
            (samplingFrequency * 600) != params.sampleCount || 
            autoDiagValue < params.minAutoDiag || 
            autoDiagValue > params.maxAutoDiag
        ) {
            success = false;
            emit DataHashStored(dataHash, endTime);  // Store invalid data hash on-chain
        } else {
            // Store valid data hash on IPFS
            emit DataSavedToIPFS(ipfsHash, endTime);
        }

        // Update last timestamp
        lastTimestamp = endTime;

        emit DataValidated(dataHash, endTime, success);
    }
}
